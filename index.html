<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>楕円ビリヤード（本格9ボール・対戦・反射ガイド）</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#0b1220; color:#e5e7eb; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }
    .wrap { max-width: 980px; margin: 24px auto; padding: 0 12px; }
    .bar { display:flex; align-items:center; justify-content:space-between; background:#0f172a; border-radius:12px; padding:10px 12px; gap: 10px; flex-wrap: wrap; }
    .row { display:flex; align-items:center; gap:10px; }
    .pill { padding:2px 8px; border-radius:8px; background:#1f2937; }
    .pill.turn { background:#059669; color:#fff; }
    .pill.target { background:#0ea5e9; color:#0b1220; font-weight:600; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; }
    .panel { position:relative; border:1px solid #334155; border-radius:16px; overflow:hidden; box-shadow:0 10px 24px rgba(0,0,0,.3); margin-top:12px; }
    .overlay { position:absolute; left:8px; top:8px; font-size:12px; background:rgba(0,0,0,.6); padding:4px 8px; border-radius:6px; }
    .msg { position:absolute; left:8px; bottom:8px; font-size:12px; background:rgba(0,0,0,.6); padding:4px 8px; border-radius:6px; }
    .banner { position:absolute; right:8px; top:8px; font-size:13px; background:#f59e0b; color:#111827; padding:6px 10px; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,.25); display:none; }
    .modal { position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.55); }
    .card { background:#0f172a; border:1px solid #334155; border-radius:14px; padding:16px 18px; min-width: 280px; box-shadow: 0 20px 60px rgba(0,0,0,.35); }
    .card h2 { margin:0 0 8px 0; font-size:18px; }
    .card .sub { opacity:.8; font-size:13px; margin-bottom:12px; }
    .btn { background:#22c55e; color:#052e12; border:none; border-radius:10px; padding:8px 12px; font-weight:600; cursor:pointer; }
    .btn:hover { filter:brightness(1.05); }
    canvas { display:block; background:#0a5a2c; touch-action:none; } /* ← iPadでの誤スクロール防止 */
    label.pill input { accent-color:#0ea5e9; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="bar">
      <strong>楕円ビリヤード（本格9ボール・対戦・反射ガイド）</strong>
      <div class="row">
        <span class="pill target">ターゲット: <span id="targetNum">1</span></span>
        <label class="pill" style="display:flex;align-items:center;gap:6px;cursor:pointer;">
          <input id="guideToggle" type="checkbox" checked /> 反射ガイド
        </label>
      </div>
      <div class="row">
        <div class="row">
          <input id="p1name" value="P1" />
          <span id="p1score" class="pill mono">0</span>
        </div>
        <div class="row">
          <input id="p2name" value="P2" />
          <span id="p2score" class="pill mono">0</span>
        </div>
        <button id="pauseBtn">一時停止</button>
        <button id="rackBtn">R: 初期配置</button>
      </div>
    </div>
    <div class="panel">
      <canvas id="table" width="900" height="620"></canvas>
      <div class="overlay">ドラッグでショット / （BIH中）クリックで手球配置 / Space 一時停止 / R 初期配置</div>
      <div id="bih" class="banner">手球フリー配置中（テーブルをクリック）</div>
      <div id="msg" class="msg">最小番号から当ててね！</div>
      <div id="modal" class="modal">
        <div class="card">
          <h2 id="modalTitle">ラウンド終了</h2>
          <div id="modalSub" class="sub"></div>
          <button id="nextBtn" class="btn">次のラックへ</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ====== Geometry & Physics ======
    const W=900,H=620,cx=W/2,cy=H/2,a=360,b=240;
    const c=Math.sqrt(Math.max(0,a*a-b*b));
    const R=9,MU=0.85,RESTITUTION=0.96,CUSHION_REST=0.92,MAX_POWER=820,POCKET_R=18;
    const pocketAngles=[0,Math.PI/3,2*Math.PI/3,Math.PI,4*Math.PI/3,5*Math.PI/3];
    const pockets=pocketAngles.map(th=>({x:a*Math.cos(th),y:b*Math.sin(th)}));
    const colors9=['#ffd700','#0000ff','#ff0000','#9400d3','#ffa500','#00ff00','#800000','#000000','#1e90ff'];

    // ====== DOM ======
    const canvas=document.getElementById('table'), ctx=canvas.getContext('2d');
    const p1nameEl=document.getElementById('p1name'), p2nameEl=document.getElementById('p2name');
    const p1scoreEl=document.getElementById('p1score'), p2scoreEl=document.getElementById('p2score');
    const msgEl=document.getElementById('msg'), pauseBtn=document.getElementById('pauseBtn'), rackBtn=document.getElementById('rackBtn');
    const bihBanner=document.getElementById('bih'), targetEl=document.getElementById('targetNum');
    const guideToggle=document.getElementById('guideToggle');
    const modal=document.getElementById('modal'), modalTitle=document.getElementById('modalTitle'), modalSub=document.getElementById('modalSub'), nextBtn=document.getElementById('nextBtn');

    // ====== State ======
    let balls=[]; // {id,x,y,vx,vy,r,m,color,isCue,label}
    let running=true, aiming=null, last=0, ballInHand=false, shotActive=false;
    let firstContact=null, pocketedThisShot=[];
    let requiredLowest=null, touchedRequired=false;
    let p1Score=0,p2Score=0,currentPlayer=1;
    let gameOver=false, lastWinner=1;

    function playerName(p){return p===1?p1nameEl.value:p2nameEl.value;}
    function addScore(p,d){ if(p===1){ p1Score=Math.max(0,p1Score+d); p1scoreEl.textContent=p1Score; } else { p2Score=Math.max(0,p2Score+d); p2scoreEl.textContent=p2Score; } }
    function allStopped(th=2){ return balls.every(b=>Math.hypot(b.vx,b.vy)<th); }
    function lowest(){ const ids=balls.filter(b=>!b.isCue).map(b=>b.id); return ids.length?Math.min(...ids):null; }
    function setTurnDisplay(p){ p1scoreEl.classList.toggle('turn', p===1); p2scoreEl.classList.toggle('turn', p===2); }
    function switchTurn(){ currentPlayer=currentPlayer===1?2:1; setTurnDisplay(currentPlayer); }
    function setMsg(t){ msgEl.textContent=t; }
    function setBIHBanner(show){ bihBanner.style.display = show ? 'block' : 'none'; }
    function updateTargetLabel(){ 
      const t = shotActive ? ((requiredLowest != null) ? requiredLowest : lowest()) : lowest(); 
      targetEl.textContent = (t != null) ? t : '-'; 
    }

    function openModal(title, sub){ modalTitle.textContent = title; modalSub.textContent = sub || ''; modal.style.display = 'flex'; gameOver = true; running = false; }
    function closeModal(){ modal.style.display = 'none'; gameOver = false; running = true; }
    function showRackResult(reason){ let title, sub; if(p1Score>p2Score){ lastWinner=1; title=`勝者: ${playerName(1)}`; } else if(p2Score>p1Score){ lastWinner=2; title=`勝者: ${playerName(2)}`; } else { lastWinner=(lastWinner===1?2:1); title='引き分け'; } sub = `${reason}  ${playerName(1)}:${p1Score} - ${playerName(2)}:${p2Score}`; openModal(title, sub); }

    // ====== Math helpers ======
    function add(ax,ay,bx,by){ return {x:ax+bx,y:ay+by}; }
    function norm(ax,ay){ const d=Math.hypot(ax,ay)||1; return {x:ax/d,y:ay/d}; }
    function inside(x,y,A=a,B=b){ return (x*x)/(A*A)+(y*y)/(B*B) <= 1; }
    function project(x,y,A=a,B=b){ const f=(x*x)/(A*A)+(y*y)/(B*B); if(f===0) return {x:0,y:0}; const s=1/Math.sqrt(f); return {x:x*s,y:y*s}; }
    function reflect(vx,vy,bx,by,A,B){ const nx=bx/(A*A),ny=by/(B*B),nlen=Math.hypot(nx,ny)||1,ux=nx/nlen,uy=ny/nlen,d=vx*ux+vy*uy; return {vx:(vx-2*d*ux)*CUSHION_REST,vy:(vy-2*d*uy)*CUSHION_REST}; }
    function rayEllipse(p, v, A, B){ const a0 = (v.x*v.x)/(A*A) + (v.y*v.y)/(B*B); const b0 = 2*((p.x*v.x)/(A*A) + (p.y*v.y)/(B*B)); const c0 = (p.x*p.x)/(A*A) + (p.y*p.y)/(B*B) - 1; const disc = b0*b0 - 4*a0*c0; if(disc < 0 || a0===0) return null; const s = Math.sqrt(disc); const t1 = (-b0 - s)/(2*a0), t2 = (-b0 + s)/(2*a0); const t = (t1>1e-6 ? t1 : (t2>1e-6 ? t2 : null)); if(t==null) return null; return { t, hit: add(p.x,p.y, v.x*t, v.y*t) }; }
    function reflectVec(vx,vy,px,py,A,B){ const nx=px/(A*A),ny=py/(B*B),nlen=Math.hypot(nx,ny)||1,ux=nx/nlen,uy=ny/nlen,d=vx*ux+vy*uy; return {x:(vx-2*d*ux), y:(vy-2*d*uy)}; }

    // ====== Game helpers ======
    // ====== Power Gauge ======
    function getAimPower(){
      // ドラッグで狙っている間だけ計算（古いSafari互換）
      if(!aiming || !aiming.active) return 0;
      const dx = aiming.sx - aiming.mx, dy = aiming.sy - aiming.my;
      const dist = Math.hypot(dx, dy);
      return Math.min(MAX_POWER, dist * 8);
    }

    function drawPowerGauge(){
      // ドラッグ中のみ表示（古いSafari互換）
      if(!aiming || !aiming.active) return;

      const power = getAimPower();
      const pct   = power / Math.max(1, MAX_POWER);

      // キャンバス左上の少し下（HUDとかぶらないように）
      const x = 20, y = 68, w = 220, h = 14;

      ctx.save();
      ctx.globalAlpha = 0.9;

      // 背景パネル
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(x-4, y-4, w+8, h+8);

      // バー土台
      ctx.fillStyle = 'rgba(15,23,42,0.95)';
      ctx.fillRect(x, y, w, h);

      // バー本体（緑→黄→赤のグラデ）
      const g = ctx.createLinearGradient(x, y, x + w, y);
      g.addColorStop(0,   '#22c55e');
      g.addColorStop(0.5, '#f59e0b');
      g.addColorStop(1,   '#ef4444');
      ctx.fillStyle = g;
      ctx.fillRect(x, y, Math.max(2, Math.floor(w * pct)), h);

      // 枠線
      ctx.strokeStyle = '#94a3b8';
      ctx.lineWidth = 1;
      ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);

      // テキスト
      ctx.fillStyle = '#e5e7eb';
      ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText('Power: ' + Math.round(pct * 100) + '%', x, y + h + 14);

      ctx.restore();
    }

    function rack(){
      const cue={id:0,x:-c*0.9,y:0,vx:0,vy:0,r:R,m:1,color:'#f1f5f9',isCue:true};
      const gap = R*2.05; const headX = +c*0.55, headY = 0;
      const diamondOffsets = [ [0,0], [gap,-gap/2],[gap,+gap/2], [2*gap,-gap],[2*gap,0],[2*gap,+gap], [3*gap,-gap/2],[3*gap,+gap/2], [4*gap,0] ];
      const positions = diamondOffsets.map(function(d){ return { x: headX + d[0], y: headY + d[1] }; });
      const objs=[];
      objs.push({ id:1, x:positions[0].x, y:positions[0].y, vx:0, vy:0, r:R, m:1, color:colors9[0], label:'1' });
      objs.push({ id:9, x:positions[4].x, y:positions[4].y, vx:0, vy:0, r:R, m:1, color:colors9[8], label:'9' });
      const remainIds=[2,3,4,5,6,7,8];
      for(let i=remainIds.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); const tmp=remainIds[i]; remainIds[i]=remainIds[j]; remainIds[j]=tmp; }
      const remainSlots=[1,2,3,5,6,7,8];
      for(let k=0;k<remainIds.length;k++){
        const id=remainIds[k], idx=remainSlots[k], p=positions[idx], color=colors9[id-1];
        objs.push({ id, x:p.x, y:p.y, vx:0, vy:0, r:R, m:1, color, label:String(id) });
      }
      balls=[cue].concat(objs);
      firstContact=null; pocketedThisShot=[]; shotActive=false; requiredLowest=null; touchedRequired=false;
      setTurnDisplay(currentPlayer); setMsg('新ラック：最小番号から当ててね！'); setBIHBanner(false); ballInHand=false; updateTargetLabel();
    }

    function spotBall(id){
      const A=a-R,B=b-R;
      const baseX=+c*0.55+2*R*2.05, baseY=0; const gap=R*2.05;
      const tryPoints=[[baseX,baseY],[baseX+gap,baseY],[baseX-gap,baseY],[baseX,baseY+gap],[baseX,baseY-gap],[baseX+gap,baseY+gap/2],[baseX+gap,baseY-gap/2]];
      function freeAt(x,y){ return balls.every(b=>Math.hypot(b.x-x,b.y-y)>=b.r+R+1); }
      function place(x,y){ const idx=balls.findIndex(b=>b.id===id); if(idx>=0){ const b=balls[idx]; b.x=x;b.y=y;b.vx=b.vy=0; } }
      for(let i=0;i<tryPoints.length;i++){
        const x=tryPoints[i][0], y=tryPoints[i][1];
        const f=(x*x)/(A*A)+(y*y)/(B*B);
        if(f<=1 && freeAt(x,y)){ place(x,y); return; }
      }
      place(Math.min(Math.max(baseX,-A),A), Math.min(Math.max(baseY,-B),B));
    }

    // ====== Input ======
    canvas.addEventListener('pointerdown', function(e){
      const r=canvas.getBoundingClientRect();
      const x=e.clientX-r.left-cx, y=e.clientY-r.top-cy;
      const cue=balls.find(b=>b.isCue);
      if(allStopped() && ballInHand && inside(x,y,a-R,b-R)){
        cue.x=x; cue.y=y; cue.vx=cue.vy=0; ballInHand=false; setMsg('手球を配置しました'); setBIHBanner(false); updateTargetLabel(); return;
      }
      if(!allStopped() || gameOver) return;
      if(Math.hypot(x-cue.x,y-cue.y)<=R*2.2){ aiming={active:true,sx:cue.x,sy:cue.y,mx:x,my:y}; }
    });

    window.addEventListener('pointermove', function(e){
      if(!aiming || !aiming.active) return;
      const r=canvas.getBoundingClientRect();
      const x=e.clientX-r.left-cx, y=e.clientY-r.top-cy;
      aiming.mx=x; aiming.my=y;
    });

    window.addEventListener('pointerup', function(){
      const aim=aiming; if(!aim || !aim.active) return;
      aiming=null;
      const cue=balls.find(b=>b.isCue);
      const dx=aim.sx-aim.mx, dy=aim.sy-aim.my, dist=Math.hypot(dx,dy);
      const power=Math.min(MAX_POWER, dist*8); if(power<5) return;
      const ux=dx/(dist||1), uy=dy/(dist||1);
      cue.vx=ux*power; cue.vy=uy*power;
      requiredLowest = lowest(); touchedRequired=false; firstContact=null; pocketedThisShot=[];
      shotActive=true; setMsg((currentPlayer===1?p1nameEl.value:p2nameEl.value)+' のショット！'); updateTargetLabel();
    });

    window.addEventListener('keydown', function(e){
      if(e.key===' '){ running=!running; pauseBtn.textContent = running? '一時停止' : '再開'; }
      if(e.key==='r' || e.key==='R'){ rack(); }
    });

    const pauseHandler=function(){ running=!running; pauseBtn.textContent = running? '一時停止' : '再開'; };
    pauseBtn.addEventListener('click', pauseHandler);
    rackBtn.addEventListener('click', rack);
    nextBtn.addEventListener('click', function(){
      closeModal(); p1Score=0; p2Score=0; p1scoreEl.textContent='0'; p2scoreEl.textContent='0';
      currentPlayer=lastWinner; setTurnDisplay(currentPlayer); rack();
    });

    // ====== Simulation ======
    function update(dt){
      const A=a-R,B=b-R; const sunk=[];
      for(let i=0;i<balls.length;i++){
        const ball=balls[i];
        const damp=Math.exp(-MU*dt); ball.vx*=damp; ball.vy*=damp;
        let nx=ball.x+ball.vx*dt, ny=ball.y+ball.vy*dt;

        // ポケット判定
        let willSink=false;
        for(let p=0;p<pockets.length;p++){
          const pk=pockets[p];
          if(Math.hypot(nx-pk.x,ny-pk.y)<POCKET_R-1){ willSink=true; break; }
        }
        if(willSink){ sunk.push(ball.id); continue; }

        // クッション反射 or 位置更新
        const f=(nx*nx)/(A*A)+(ny*ny)/(B*B);
        if(f>1){
          let near=false;
          for(let p=0;p<pockets.length;p++){
            const pk=pockets[p];
            if(Math.hypot(nx-pk.x,ny-pk.y)<POCKET_R+6){ near=true; break; }
          }
          if(near){
            sunk.push(ball.id);
          }else{
            const pb=project(nx,ny,A,B), rv=reflect(ball.vx,ball.vy,pb.x,pb.y,A,B);
            ball.vx=rv.vx; ball.vy=rv.vy; ball.x=pb.x*0.999; ball.y=pb.y*0.999;
          }
        } else {
          ball.x=nx; ball.y=ny;
        }

        if(Math.hypot(ball.vx,ball.vy)<1){ ball.vx=0; ball.vy=0; }
      }

      // 玉同士の衝突
      for(let i=0;i<balls.length;i++){
        for(let j=i+1;j<balls.length;j++){
          const A1=balls[i], B1=balls[j];
          const dx=B1.x-A1.x, dy=B1.y-A1.y, dist=Math.hypot(dx,dy), minDist=A1.r+B1.r;
          if(dist>0 && dist<minDist){
            const ux=dx/dist, uy=dy/dist, overlap=minDist-dist;
            A1.x-=ux*(overlap/2); A1.y-=uy*(overlap/2);
            B1.x+=ux*(overlap/2); B1.y+=uy*(overlap/2);
            const rvx=B1.vx-A1.vx, rvy=B1.vy-A1.vy, vn=rvx*ux+rvy*uy;
            if(vn<0){
              const e=RESTITUTION, j=-(1+e)*vn/(1/A1.m+1/B1.m), jx=j*ux, jy=j*uy;
              A1.vx-=jx/A1.m; A1.vy-=jy/A1.m; B1.vx+=jx/B1.m; B1.vy+=jy/B1.m;
            }
            const cue=A1.isCue?A1:(B1.isCue?B1:null);
            const other=cue?(cue===A1?B1:A1):null;
            if(cue && other && !other.isCue){
              if(firstContact===null){ firstContact = other.id; }
              if(requiredLowest!=null && other.id===requiredLowest){ touchedRequired = true; }
            }
          }
        }
      }

      // 落球処理
      if(sunk.length){
        sunk.sort(function(a,b){ return a===0?-1:1; });
        for(let i=0;i<sunk.length;i++){
          const id=sunk[i]; const idx=balls.findIndex(b=>b.id===id);
          if(idx>=0){
            const b=balls[idx];
            if(b.isCue){
              addScore(currentPlayer,-1);
              b.x=-c*0.9; b.y=0; b.vx=0; b.vy=0;
              setMsg('スクラッチ：-1点、相手に手球（テーブルをクリックで手球配置）');
              ballInHand=true; setBIHBanner(true);
            } else {
              balls.splice(idx,1);
              pocketedThisShot.push(id);
            }
          }
        }
      }

      // ショット終了判定
      if(shotActive && allStopped()){
        const foul = (requiredLowest!=null && !touchedRequired);

        if(foul){
          if(pocketedThisShot.indexOf(9)!==-1){
            const id=9;
            if(!balls.some(function(bb){return bb.id===id;})){
              const color=colors9[id-1];
              balls.push({id:id, x:0, y:0, vx:0, vy:0, r:R, m:1, color:color, label:String(id)});
            }
            spotBall(9);
          }
          addScore(currentPlayer,-1);
          setMsg('ファウル：相手にボールインハンド（9のみスポット戻し）');
          switchTurn(); ballInHand=true; setBIHBanner(true);

        } else {
          if(pocketedThisShot.indexOf(9)!==-1){
            addScore(currentPlayer,3);
            showRackResult('9ボール達成！');
          } else {
            let gained=0;
            for(let i=0;i<pocketedThisShot.length;i++){ gained += 1; }
            if(gained>0) addScore(currentPlayer,gained);

            if(!balls.some(function(b){ return !b.isCue; })){
              addScore(currentPlayer,3);
              showRackResult('全クリア！');
            } else {
              if(gained>0){
                setMsg('+'+gained+'点 続行');
              } else {
                switchTurn();
                setMsg((currentPlayer===1?p1nameEl.value:p2nameEl.value)+' の番');
              }
            }
          }
        }

        firstContact=null; pocketedThisShot=[];
        shotActive=false; requiredLowest=null; touchedRequired=false;
        updateTargetLabel();
      }
    }

    // ====== Prediction guides（薄い破線：入射→反射のみ） ======
    function drawGuides(){
      if(!guideToggle || !guideToggle.checked) return;
      if(!aiming || !aiming.active) return;
      if(gameOver) return;

      const cue = balls.find(b=>b.isCue); if(!cue) return;
      const dx = aiming.sx - aiming.mx, dy = aiming.sy - aiming.my; const dlen=Math.hypot(dx,dy); if(dlen<1) return;
      const u={x:dx/dlen,y:dy/dlen}; const start={x:cue.x,y:cue.y};
      const A=a-R, B=b-R;
      const hit1 = rayEllipse(start,u,A,B);

      ctx.save(); ctx.translate(cx,cy);
      ctx.setLineDash([6,6]); ctx.globalAlpha=0.6; ctx.lineWidth=2; ctx.strokeStyle='#e5e7eb';

      if(!hit1){
        const far={x:start.x+u.x*1100, y:start.y+u.y*1100};
        ctx.beginPath(); ctx.moveTo(start.x,start.y); ctx.lineTo(far.x,far.y); ctx.stroke();
        ctx.restore(); ctx.setLineDash([]); ctx.globalAlpha=1; return;
      }

      ctx.beginPath(); ctx.moveTo(start.x,start.y); ctx.lineTo(hit1.hit.x,hit1.hit.y); ctx.stroke();
      ctx.setLineDash([]); ctx.fillStyle='rgba(229,231,235,0.6)'; ctx.beginPath(); ctx.arc(hit1.hit.x,hit1.hit.y,3,0,Math.PI*2); ctx.fill();

      const rv=reflectVec(u.x,u.y,hit1.hit.x,hit1.hit.y,A,B);
      const len=Math.hypot(rv.x,rv.y)||1; const dir={x:rv.x/len,y:rv.y/len};
      const hit2=rayEllipse(hit1.hit,dir,A,B);
      const end=hit2?hit2.hit:{x:hit1.hit.x+dir.x*700,y:hit1.hit.y+dir.y*700};

      ctx.setLineDash([10,10]); ctx.globalAlpha=0.6; ctx.lineWidth=2; ctx.strokeStyle='rgba(245,158,11,0.6)';
      ctx.beginPath(); ctx.moveTo(hit1.hit.x,hit1.hit.y); ctx.lineTo(end.x,end.y); ctx.stroke();

      ctx.restore(); ctx.setLineDash([]); ctx.globalAlpha=1;
    }

    // ====== Rendering ======
    function draw(){
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle='#0a5a2c'; ctx.fillRect(0,0,W,H);

      ctx.save(); ctx.translate(cx,cy);
      ctx.beginPath(); ctx.ellipse(0,0,a,b,0,0,Math.PI*2);
      ctx.strokeStyle='#77e0ff'; ctx.lineWidth=3; ctx.stroke();

      for(let i=0;i<pockets.length;i++){
        const pk=pockets[i];
        ctx.fillStyle='#0f172a'; ctx.beginPath(); ctx.arc(pk.x,pk.y,POCKET_R+3,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#020617'; ctx.beginPath(); ctx.arc(pk.x,pk.y,POCKET_R,0,Math.PI*2); ctx.fill();
      }

      const fcs = Math.sqrt(Math.max(0,a*a-b*b));
      ctx.fillStyle='#ffd166'; ctx.beginPath(); ctx.arc(-fcs,0,4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc( fcs,0,4,0,Math.PI*2); ctx.fill();

      const targetId = shotActive ? ((requiredLowest != null) ? requiredLowest : lowest()) : lowest();
      if(targetId!=null){
        const tb=balls.find(function(b){return b.id===targetId;});
        if(tb){
          const pulse = 1 + 0.15*Math.sin(performance.now()/250);
          ctx.save(); ctx.globalAlpha=0.9; ctx.strokeStyle='#38bdf8'; ctx.lineWidth=4;
          ctx.beginPath(); ctx.arc(tb.x, tb.y, tb.r*1.9*pulse, 0, Math.PI*2); ctx.stroke();
          ctx.globalAlpha=0.35; ctx.lineWidth=10;
          ctx.beginPath(); ctx.arc(tb.x, tb.y, tb.r*2.6*pulse, 0, Math.PI*2); ctx.stroke();
          ctx.restore();
        }
      }

      for(let i=0;i<balls.length;i++){
        const b=balls[i];
        ctx.fillStyle=b.color; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
        if(!b.isCue && b.label){
          ctx.fillStyle='#fff'; ctx.font='10px ui-monospace,Menlo,monospace';
          ctx.textAlign='center'; ctx.textBaseline='middle';
          ctx.fillText(b.label, b.x, b.y+0.5);
        } else if(b.isCue){
          ctx.strokeStyle='#94a3b8'; ctx.lineWidth=1; ctx.stroke();
        }
      }
      ctx.restore();

      // ガイド＆ゲージ＆ターゲット表示更新
      drawGuides();
      drawPowerGauge();
      updateTargetLabel();
    }

    // ====== Main loop ======
    function loop(t){ const dt=Math.min(0.03, (t-last)/1000 || 0.016); last=t||0; if(running) update(dt); draw(); requestAnimationFrame(loop); }
    requestAnimationFrame(loop);

    // Init
    rack(); setTurnDisplay(currentPlayer);
  </script>
</body>
</html>
